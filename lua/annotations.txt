# luac.c:
This is the Lua compiler front-end (luac).

Note: Comments based on Lua 5.2.0-alpha.

# luac.c:fatal
Utility function to display fatal error message
and exit (without cleanup).

# luac.c:cannot
Utility function display fatal I/O error
and exit (without cleanup).

# luac.c:usage
Writes command-line help to standard error
and exit (without cleanup)

# luac.c:doargs
Parse main's command line arguments.
May exit without cleanup.

# luac.c:FUNCTION
used by luac.c:reader

# luac.c:reader
lua_Reader function that outputs Lua source code consisting of
a series of "(function()end)();" repeated by the number of times
in integer *ud.

This is used to generate the initial bytecode needed by
luac when compiling multiple files (chunks) together.  This bytecode
is later patched with the addresses of the real chunks.

# luac.c:combine
On exit, the top of the stack will contain a function that calls
the previous top-most n values (functions) on the stack.

This is used to generate the initial bytecode needed by
luac when compiling multiple files (chunks) together.

# luac.c:writer
lua_Writer function used to dump generated bytecode to a file.

# luac.c:pmain
Main code, protected by pcall.

# luac.c:main
Main code, entry point.

# luac.c:PrintString
Dump string object (quoted and escaped) to standard output.

# luac.c:PrintConstant
Dump i-th constant in function prototype f.

# luac.c:PrintCode
Dump all opcodes in function prototype f.

# luac.c:PrintHeader
Dump metadata on function prototype f.

# luac.c:PrintDebug
Dump all constants/locals/upvalues in function prototype f.

Used by undocumented "luac -l -l".

# luac.c:PrintFunction
Dump function prototype f.
If full (0 or 1) is 1, invokes PrintDebug.

# lparser.c:hasmultret
Whether expkind k has multiple return values.

# lparser.c:NILCONSTANT
Use for structure initializer of TValue object representing nil.

# lparser.c:ttype
Returns a LUA_T* value.

# lobject.h:
This files provides the types an operations on for handling
values (TValue objects) in Lua.

# lobject.h:ttisnil
Checks whether TValue o is nil.

# lobject.h:ttisnumber
Checks whether TValue o is of type number.

# lobject.h:ttislcf
Checks whether TValue o is a Lua function (or C function exposed
to Lua, not including light C functions).  Such functions have
a prototype (see getproto)

# lobject.h:ttislcf
Checks whether TValue o is a light C function (lua_CFunction).

# lobject.h:pvalue
Gets void pointer in TValue o.

# lobject.h:nvalue
Gets number (lua_Number) in TValue o (or asserts if not number).

# lobject.h:rawtsvalue
Gets string (TString) in TValue o.

# lobject.h:tsvalue
Gets string header (TString.tsv) in TValue o.

# lobject.h:uvalue
Gets userdata header (Udata.uv) in TValue o.

# lobject.h:clvalue
Gets closure (Closure - GCObject.cl) in TValue o.

# lobject.h:fvalue
Gets light C function (lua_CFunction) in TValue o.

# lobject.h:hvalue
Gets table (Table - GCobject.h) in TValue o.

# lobject.h:bvalue
Gets boolean (int) value in TValue o.

# lobject.h:thvalue
Gets thread lua_State (GCObject.th) value in Tvalue o.

# lobject.h:l_isfalse
Gets whether TValue o evaluates to false (i.e. is nil or false).

# lobject.h:setnvalue
Sets value of TValue obj to number (lua_Number) x.

# lobject.h:setfvalue
Sets value of TValue obj to light C function (lua_CFunction) x.

# lobject.h:setfvalue
Sets value of TValue obj to light user data (void*) x.

# lobject.h:setbvalue
Sets value of TValue obj to boolean (int 0..1) x.

# lobject.h:svalue
Note: TValue o -> const char *.

# lobject.h:Udata
Note: each (heavyweight) userdata can be associated with a metatable
and a user value (previously called a "userdata environment table") set
via lua_setuservalue.
A userdata is garbage collectable CommonHeader) and is allocated
as a series of `len` bytes in Lua's own memory.

# lobject.h:Upvaldesc
Note: compare to Upval.

# lobject.h:Proto
Every definition of a Lua function (or C function exposed as a Lua function)
is represented with a function prototype object.
This contains things like a list of bytecode instructions (code),
links to other constant data used by the functions
(constants, nested functions, and upvalue descriptions), and other
metadata (e.g. debugging info).

For each function prototype, any number of values may be
instantiated (allocated) based on that prototype.  For example, this:

  local t = {}
  for i=1,10 do
    t[i] = function() return i end
  end
	
creates 10 function objects that all link to the same prototype of
"function() return i end".

# lobject.h:Upvaluedesc.
Compare to UpVal, which are stored in closures (instantiations of
prototypes).

# lobject.h:UpVal
This represents upvalues.  They are stored in a closure value (LClosure).
Compare to Upvaldesc.

# lobject.h:Closure
Represents a closure (implemented via C Function or Lua function).
These are linked to TValue's, among other places.

# lobject.h:getproto
Gets the prototype (Prototype) of TValue o (assumed to be a
function, not a lightweight C function).

# lobject.h:Table
Represents a Lua table ({}).
These are linked to TValues.

Note: each table can have an optional metatable and can have
an array part (stored in array `array` of length `sizearray` and
a hash part (stored in array `node` of length encoded in `lsizenode`).

You can quickly check for certain metamethods via the `flags` field
rather than looking in the metatable.

# lobject.h:twoto
Efficiently raises 2 to the integer x power.
